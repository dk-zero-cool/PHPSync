#!/usr/bin/env php
<?php
/*
 * This file is part of the PHPSync Project: https://github.com/dk-zero-cool/phpsync
 *
 * Copyright (c) 2017 Daniel BerglÃ¸v, License: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

define("PHPSYNC_VERSION", "1.0.0");

define("FLAG_YES", 0b00001);
define("FLAG_DELETE", 0b00010);
define("FLAG_TEST", 0b00100);
define("FLAG_QUIET", 0b01000);
define("FLAG_EXTRACT", 0b10000);

$defined = [
    "FLAGS" => 0,
    "LOG_FILEPATH" => null,
    "DIR_SRC" => null,
    "DIR_DST" => null,
    "COMPR_ALGO" => "gz"
];

for ($i=1; $i < count($argv); $i++) {
    switch ($argv[$i]) {
        case "--version":
            print PHPSYNC_VERSION."\n"; exit;

        case "--algo":
            $defined["COMPR_ALGO"] = $argv[++$i];

            if (!in_array($defined["COMPR_ALGO"], ["xz", "bz", "gz", "none"])) {
                Log::write("Compression algo '%s' is not valid", $defined["COMPR_ALGO"]); exit(1);
            }

            break;

        case "--log":
            $defined["LOG_FILEPATH"] = $argv[++$i];

            if (!file_exists($defined["LOG_FILEPATH"]) && !file_exists(dirname($defined["LOG_FILEPATH"]))) {
                Log::write("The defined log path does not exist", $defined["LOG_FILEPATH"]); exit(1);

            } else if ((file_exists($defined["LOG_FILEPATH"]) && !is_writable($defined["LOG_FILEPATH"])) || (!file_exists($defined["LOG_FILEPATH"]) && !is_writable(dirname($defined["LOG_FILEPATH"])))) {
                Log::write("The log path '%s' must be writable", $defined["LOG_FILEPATH"]); exit(1);

            } else if (is_dir($defined["LOG_FILEPATH"])) {
                $defined["LOG_FILEPATH"] = rtrim($defined["LOG_FILEPATH"], "/")."/phpsync.log";
            }

            break;

        default:
            if ($argv[$i][0] == "-") {
                for ($x=1; $x < strlen($argv[$i]); $x++) {
                    switch ($argv[$i][$x]) {
                        case "y":
                            $defined["FLAGS"] |= FLAG_YES; break;

                        case "d":
                            $defined["FLAGS"] |= FLAG_DELETE; break;

                        case "t":
                            $defined["FLAGS"] |= FLAG_TEST; break;

                        case "q":
                            $defined["FLAGS"] |= FLAG_QUIET; break;

                        case "x":
                            $defined["FLAGS"] |= FLAG_EXTRACT; break;

                        default:
                            Log::write("Unknown argument '%s'", $argv[$i][$x]); exit(1);
                    }
                }

            } else {
                if (empty($defined["DIR_SRC"])) {
                    if (!is_dir($argv[$i])) {
                        Log::write("Source must be a directory"); exit(1);

                    } else if (!is_readable($argv[$i])) {
                        Log::write("Source must be readable"); exit(1);
                    }

                    $defined["DIR_SRC"] = realpath($argv[$i]);

                } else if (empty($defined["DIR_DST"])) {
                    if (!is_dir($argv[$i])) {
                        Log::write("Destination must be a directory"); exit(1);

                    } else if (!is_writable($argv[$i])) {
                        Log::write("Destination must be writable"); exit(1);
                    }

                    $defined["DIR_DST"] = realpath($argv[$i]);

                } else {
                    Log::write("Unknown argument '%s'", $argv[$i]); exit(1);
                }
            }
    }
}

foreach ($defined as $name => $value) {
    define($name, $value);
}

if (DIR_SRC === null || DIR_DST === null) {
    print "PHPSync version ".PHPSYNC_VERSION."\n\n";
    print "Syntax: " . basename($argv[0]) . " -dqtyx --algo gz --log <path> /src /dst\n\n";
    print "Sync files from src to dst\n\n";
    print "\t-d: Delete files that does not exist in src\n";
    print "\t-y: Don't ask to continue\n";
    print "\t-q: Quiet, only print to log file, except errors\n";
    print "\t-x: Extract files from src into dst\n";
    print "\t-t: Test run, just print without performing any actual actions\n\n";
    print "\t--log <path>: Path to the log file/dir\n";
    print "\t--algo <xz|bz|gz|none>: Change default compression algo\n";
    print "\t--version: Print the current PHPSync version\n\n";

    exit;

} else if ((FLAGS & FLAG_YES) == 0) {
    if (posix_geteuid() != 0) {
        print "\nWARNING: To avoid permission issues, consider running this as root!!!\n";
    }

    print "\nFrom: ".DIR_SRC."\nTo: ".DIR_DST."\n\n";
    print "Continue? [Y/N]: ";

    $line = fgets(STDIN);

    if (strtolower(trim($line)) == "n") {
        exit;
    }
}

/**
 * =====================================================================
 * ---------------------------------------------------------------------
 *  SYNC PROCESS
 *
 *      When we backup, any compressed file will get the name [name]#sync:[md5].
 *      The hash value makes the files non-unique, meaning that there
 *      could easily be multiple files with the same real name. It also makes it more
 *      dificult to check if a file exist, unless you have the complete name incl. the hash.
 *
 *      Because of this, the first round should WALWAYS be on the directory containing
 *      the files with hash valued names. That means 'dst' during backup and 'src' during restore.
 *      That way we can handle exisiting hash valued file names first and use round 2 'second'
 *      to handle files not currently synced.
 *
 *      It's important that 'src' runs 'SELF_FIRST' and 'dst' runs 'CHILD_FIRST'.
 *      We always sync from 'src' to 'dst' meaning that 'src' will be creating a lot of
 *      directories while 'dst' will be deleting some. When deleting a directory, we need to empty
 *      it first and creating them is best to do one at a time.
 */

Log::start();
Log::write("PHPSync version %s", PHPSYNC_VERSION);
Log::write("Sync started at %s", date("Y-m-d H:i"));
Log::write("Sync from '%s' to '%s'", DIR_SRC, DIR_DST);

$FILES = [];
$ITERATORS = [
    "first" => [
        "path" => (FLAGS & FLAG_EXTRACT) == 0 ? DIR_DST : DIR_SRC,
        "flags" => (FLAGS & FLAG_EXTRACT) == 0 ? RecursiveIteratorIterator::CHILD_FIRST : RecursiveIteratorIterator::SELF_FIRST
    ],

    "second" => [
        "path" => (FLAGS & FLAG_EXTRACT) == 0 ? DIR_SRC : DIR_DST,
        "flags" => (FLAGS & FLAG_EXTRACT) == 0 ? RecursiveIteratorIterator::SELF_FIRST : RecursiveIteratorIterator::CHILD_FIRST
    ],
];

foreach ($ITERATORS as $round => $iterators) {
    $iterator = new RecursiveIteratorIterator(
                    new RecursiveDirectoryIterator($iterators["path"], FilesystemIterator::SKIP_DOTS|FilesystemIterator::KEY_AS_PATHNAME|FilesystemIterator::CURRENT_AS_FILEINFO),
                        $iterators["flags"]);

    foreach($iterator as $name => $object) {
        /*
         * Create SyncFileHandler instances for 'src' and 'dst'
         */
        if (((FLAGS & FLAG_EXTRACT) == 0 && $round == "first")
                || ((FLAGS & FLAG_EXTRACT) != 0) && $round == "second") {

            $dst = new SyncFileHandler($name, DIR_DST);
            $src = new SyncFileHandler(DIR_SRC."/".$dst->path, DIR_SRC);
            $cur = $dst;
            $diff = $dst->compare($src);

        } else {
            $src = new SyncFileHandler($name, DIR_SRC);
            $dst = new SyncFileHandler(DIR_DST."/".$src->path, DIR_DST);
            $cur = $src;
            $diff = $dst->compare($src);
        }

        /*
         * Check to see if this file was handed by the first round.
         */
        if ($round == "second" && isset($FILES[($dir = dirname($cur->path))]) && in_array(basename($cur->path), $FILES[$dir])) {
            continue;
        }

        /*
         * If file modes are the only difference,
         * simply fix it and continue to the next file
         */
        if ($diff == SyncFileHandler::CMP_MODE) {
            Log::write("Changing permissions on '%s'", $cur->path);

            if (!$dst->isOwner()) {
                Log::write("You don't have permission to make changes to '%s'", $cur->path, true);

            } else if ((FLAGS & FLAG_TEST) == 0) {
                if(!$dst->touch($src, $dst->isCompressed())) {
                    Log::write("Failed to change permissions on '%s'", $cur->path, true);
                }
            }

        } else if ($diff != SyncFileHandler::CMP_OK && $src->exists()) {
            if ((FLAGS & FLAG_EXTRACT) == 0) {
                Log::write("Backing up file '%s'", $cur->path);

            } else {
                Log::write("Restoring file '%s'", $cur->path);
            }

            if (!$src->isReadable()) {
                Log::write("You don't have permission to access the source of '%s'", $cur->path, true);

            } else if (!$dst->isWritable()) {
                Log::write("You don't have permission to modify the destination of '%s'", $cur->path, true);

            } else if ((FLAGS & FLAG_TEST) == 0) {
                if ((FLAGS & FLAG_EXTRACT) == 0 && !$dst->backup($src)) {
                    Log::write("Failed to backup file '%s'", $cur->path, true);

                } else if ((FLAGS & FLAG_EXTRACT) != 0 && !$dst->restore($src)) {
                    Log::write("Failed to restore file '%s'", $cur->path, true);
                }
            }

        } else if (!$src->exists()) {
            /*
             * This is never used when we loop against 'src', only on 'dst'.
             * We don't need to check which one is currently being used since looping on 'src'
             * will only provide files that exists, hence it will never parse the condition above.
             */
            if ((FLAGS & FLAG_DELETE) != 0) {
                Log::write("Deleting file '%s'", $cur->path);

                if (!$dst->isWritable()) {
                    Log::write("You don't have permission to delete the destination of '%s'", $cur->path, true);

                } else if ((FLAGS & FLAG_TEST) == 0) {
                    if (!$dst->remove()) {
                        Log::write("Failed to delete file '%s'", $cur->path, true);
                    }
                }

            } else {
                Log::write("Not deleting file '%s'", $cur->path);
            }
        }

        /*
         * Cache this file so that we don't waste time
         * on it during second round.
         */
        if ($round == "first" && ($cur->exists() || (FLAGS & FLAG_TEST) != 0)) {
            $dir = dirname($cur->path);

            if (!isset($FILES[$dir])) {
                $FILES[$dir] = [];
            }

            $FILES[$dir][] = basename($cur->path);
        }
    }
}

Log::write("Sync finished with %d error(s)", Log::getErrCount());
Log::stop();

/**
 * =====================================================================
 * ---------------------------------------------------------------------
 *  LOG MANAGER
 *
 *      Static class used to handle log and shell output
 */
class Log {

    private static /*stream*/ $logIO;
    private static /*int*/ $errCount = 0;
    private static /*bool*/ $started = false;

    public static function start(): void {
        static::$started = true;

        if (!is_resource(static::$logIO) && LOG_FILEPATH !== null) {
            static::$logIO = fopen(LOG_FILEPATH, "w");
        }
    }

    public static function stop(): void {
        static::$started = false;

        if (is_resource(static::$logIO)) {
            fclose(static::$logIO);
        }
    }

    public static function write(string $msg, /*mixed*/ ...$args): void {
        $err = false;

        if (count($args) > 0) {
            if (is_bool($args[count($args)-1])) {
                $err = array_pop($args);

                if ($err) {
                    static::$errCount++;
                }
            }

            $msg = sprintf($msg, ...$args);
        }

        if (!static::$started || ((FLAGS & FLAG_QUIET) == 0 || $err)) {
            if ($err) {
                fwrite(STDERR, "\tE: $msg\n");

            } else {
                fwrite(STDIN, $msg."\n");
            }
        }

        if (is_resource(static::$logIO)) {
            fwrite(static::$logIO, ((FLAGS & FLAG_QUIET) != 0 ? "\tE: " : "").$msg."\n");
        }
    }

    public static function getErrCount(): int {
        return static::$errCount;
    }
}

/**
 * =====================================================================
 * ---------------------------------------------------------------------
 *  COMPRESSION HANDLER
 *
 *      This is a compression wrapper.
 *      It allows us to keep everything regarding compression
 *      in one single place, providing simple tools that can be used
 *      elsewhere to initiate file compression/decompression.
 */
class ComprHandler {

    private /*string*/ $mFile;
    private /*string*/ $mAlgo;

    public function __construct(string $file, string $algo="gz") {
        $this->mFile = $file;
        $this->mAlgo = $algo;
    }

    private function readLine(/*resource*/ $stream): ?string {
        $hash = "";

        switch ($this->mAlgo) {
            case "bz":
                while(!feof($stream)) {
                    $buffer = bzread($stream, 16);

                    if ($buffer === false || bzerrno($stream) !== 0) {
                        return null;

                    } else if (($pos = strpos($buffer, "\n")) !== false) {
                        /*
                         * Seek the pointer to right after the LF character
                         */
                        fseek($stream, -($pos-1), SEEK_CUR);
                        $hash .= substr($buffer, 0, $pos); break;

                    } else {
                        $hash .= $buffer;
                    }
                }

                break;

            case "xz":
                $hash = fgets($stream); break;

            default:
                $hash = gzgets($stream);
        }

        /*
         * Note: Trim is important as fgets and gzgets returns the LF character
         */
        return $hash !== false && !empty($hash) ? trim($hash) : null;
    }

    public function getHeader(): ?string {
        switch ($this->mAlgo) {
            case "bz":
                $stream = bzopen($this->mFile, "r");
                if (is_resource($stream)) {
                    $hash = $this->readLine($stream);
                    bzclose($stream);

                    return $hash;
                }

            case "xz":
                $stream = fopen($this->mFile, "rb");
                if (is_resource($stream)) {
                    $hash = $this->readLine($stream);
                    fclose($stream);

                    return $hash;
                }

            default:
                $stream = gzopen($this->mFile, "r");
                if (is_resource($stream)) {
                    $hash = $this->readLine($stream);
                    gzclose($stream);

                    return $hash;
                }
        }

        return null;
    }

    public function compress(string $src, string $header): bool {
        switch ($this->mAlgo) {
            case "xz":
                /*
                 * Temp. convert the binary hash into hex.
                 * The binary data may contain characters that can cause problems when sending
                 * commands as string to the shell. We use 'xxd' to convert it back via pipe,
                 * before adding it to the file.
                 */
                passthru("echo -n '".bin2hex($header)."' | xxd -r -p | sed 's/$/\\n/' > '".$this->mFile."' && cat '".$src."' | xz >> '".$this->mFile."'", $result);

                return $result === 0;

            default:
                $result = false;
                $input = fopen($src, "r");

                if (is_resource($input)) {
                    $output = $this->mAlgo == "bz" ?
                        bzopen($this->mFile, "w") : gzopen($this->mFile, "w");

                    if (is_resource($output)) {
                        $result = $this->mAlgo == "bz" ?
                            bzwrite($output, $header."\n") : gzwrite($output, $header."\n");

                        while ($result !== false && !feof($input)) {
                            $buffer = fread($input, 8192);

                            if ($buffer !== false) {
                                $result = $this->mAlgo == "bz" ?
                                    bzwrite($output, $buffer) : gzwrite($output, $buffer);

                            } else {
                                $result = false; break;
                            }
                        }

                        if ($this->mAlgo == "bz") {
                            bzclose($output);
                        } else {
                            gzclose($output);
                        }
                    }

                    fclose($input);
                }

                return $result !== false;
        }
    }

    public function decompress(string $dst): bool {
        switch ($this->mAlgo) {
            case "xz":
                /*
                 * Temp. convert the binary hash into hex.
                 * The binary data may contain characters that can cause problems when sending
                 * commands as string to the shell. We use 'xxd' to convert it back via pipe,
                 * before adding it to the file.
                 */
                passthru("cat '".$this->mFile."' | sed '1d' | xz -d > '".$dst."'", $result);

                return $result === 0;

            default:
                $result = false;
                $input = $this->mAlgo == "bz" ?
                    bzopen($this->mFile, "r") : gzopen($this->mFile, "r");

                if (is_resource($input)) {
                    $output = fopen($dst, "w");

                    if (is_resource($output)) {
                        // Remove hash header
                        $this->readLine($input);

                        $result = true;
                        while ($result !== false && !feof($input)) {
                            $buffer = $this->mAlgo == "bz" ?
                                bzread($input, 8192) : gzread($input, 8192);

                            if ($buffer !== false) {
                                $result = fwrite($output, $buffer);

                            } else {
                                $result = false; break;
                            }

                            if ($this->mAlgo == "bz" && bzerrno($input) !== 0) {
                                $result = false; break;
                            }
                        }

                        if ($this->mAlgo == "bz") {
                            bzclose($output);
                        } else {
                            gzclose($output);
                        }
                    }

                    fclose($input);
                }

                return $result !== false;
        }
    }
}

/**
 * =====================================================================
 * ---------------------------------------------------------------------
 *  FILE HANDLER
 *
 *      This is a file wrapper containing all the required tools
 *      like collecting information about files/folders/links,
 *      compression status, file names, performing compression/decompression,
 *      handling permissions and more.
 *
 *      This wrapper helps to keep the actual sync code small, clean
 *      and easily readable.
 */
class SyncFileHandler {

    const CMP_OK = 0;
    const CMP_TYPE = 1;
    const CMP_TARGET = 2;
    const CMP_SUM = 3;
    const CMP_MODE = 4;

    private /*string*/ $mFile;
    private /*string*/ $mName;
    private /*string*/ $mPath;
    private /*string*/ $mSum = null;
    private /*string*/ $mAlgo = null;

    /*
     * mFile ($this->file)
     *      This points to the complete path of the actual file.
     *
     * mName (this->path)
     *      This points to the complete path of the file, but
     *      with the original file name. That means that if
     *      the file is compressed, the appended sum and algo info
     *      has been stripped.
     *
     * mPath (this->path)
     *      This points to the virtual file.
     *      That means the complete path and original name,
     *      but without any 'src' or 'dst' path.
     */

    public function __construct(string $file, string $base=null) {
        $this->mFile = $file;
        $this->mName = $file;
        $this->mPath = $file;

        if (($pos = strrpos($file, "#")) !== false && preg_match("/#(?:xz|bz|gz):[0-9a-f]+$/", $file)) {
            $this->mAlgo = substr($file, $pos+1, (($pos2 = strrpos($file, ":"))-($pos+1)));
            $this->mSum = substr($file, $pos2+1);
            $this->mName = substr($file, 0, $pos);
            $this->mPath = $this->mName;
        }

        if ($base != null && strpos($this->mName, $base) === 0) {
            $this->mPath = trim(substr($this->mName, strlen($base)), "/");
        }
    }

    public function __get(/*string*/ $name) /*mixed*/ {
        switch ($name) {
            case "file":
                return $this->mFile;

            case "name":
                return $this->mName;

            case "path":
                return $this->mPath;

            case "linkTarget":
                if (is_link($this->mFile)) {
                    return readlink($this->mFile);
                }

                return null;

            case "sum":
                if ($this->mSum === null && file_exists($this->mFile)) {
                    return substr(sha1_file($this->mFile), 0, 7);
                }

                return $this->mSum;

            case "hash":
                if (file_exists($this->mFile)) {
                    if ($this->isCompressed()) {
                        $handler = new ComprHandler($this->mFile, $this->algo);
                        $header = $handler->getHeader();

                        if (!empty($header)) {
                            return $header;
                        }

                    } else {
                        return sha1_file($this->mFile, true);
                    }
                }

                return null;

            case "type":
                if (is_link($this->mFile)) {
                    return "l";

                } else if (is_dir($this->mFile)) {
                    return "d";

                } else if (is_file($this->mFile)) {
                    return "f";

                } else {
                    return "v";
                }

            case "algo":
                return $this->mAlgo ?? COMPR_ALGO;

            case "size":
                if (is_file($this->mFile)) {
                    return filesize($this->mFile);
                }

                return 0;
        }

        $trace = debug_backtrace();

        throw new RuntimeException(
            'Undefined property via __get(): ' . $name .
            ' in ' . $trace[0]['file'] .
            ' on line ' . $trace[0]['line']
        );
    }

    public function exists(): bool {
        return file_exists($this->file);
    }

    public function isDir(): bool {
        return is_dir(($file = $this->file)) && !is_link($file);
    }

    public function isFile(): bool {
        return is_file(($file = $this->file)) && !is_link($file);
    }

    public function isLink(): bool {
        return is_link($this->file);
    }

    public function isCompressed(): bool {
        return preg_match("/#(?:xz|bz|gz):[0-9a-f]+$/", $this->file);
    }

    public function isReadable(): bool {
        if ($this->exists()) {
            return is_readable($this->file);
        }

        return true;
    }

    public function isWritable(): bool {
        if ($this->exists() && !is_writable($this->file)) {
            return false;
        }

        if (is_dir(($dir = dirname($this->file)))) {
            return is_writable($dir);
        }

        return true;
    }

    public function isOwner(): bool {
        if ($this->exists()) {
            $uid = posix_geteuid();

            if ($uid == 0 || $uid == fileowner($this->file)) {
                return true;
            }
        }

        return true;
    }

    public function compare(SyncFileHandler $fileInfo): int {
        if ($this->type != $fileInfo->type) {
            return static::CMP_TYPE;

        } else if ($this->isLink() && $this->linkTarget !== $fileInfo->linkTarget) {
            return static::CMP_TARGET;

        } else if ($this->isFile() && $this->sum !== $fileInfo->sum) {
            return static::CMP_SUM;

        } else {
            $stat1 = $this->isLink() ? lstat($this->file) : stat($this->file);
            $stat2 = $fileInfo->isLink() ? lstat($fileInfo->file) : stat($fileInfo->file);

            if (strcmp($stat1["mtime"], $stat2["mtime"]) != 0 && $this->isFile()) {
                if (strcmp($this->hash, $fileInfo->hash) != 0) {
                    return static::CMP_SUM;
                }
            }

            /*
             * If this script is running as regular user, any copied files and folders
             * will get the running user as owner. The script will not add another user as owner
             * while not running as root. This means of cause that the owner in these circomstances will differ
             * beween 'src' and 'dst'. So to avoid the script trying to fix it every time, which it will not do,
             * we do not report any issues if owner of a file is the running user while not root.
             */
            $uid = posix_geteuid();
            if (strcmp($stat1["mode"], $stat2["mode"]) != 0
                || (strcmp($stat1["uid"], $stat2["uid"]) != 0 && ($uid == 0 || strcmp($stat1["uid"], $uid) != 0))
                || strcmp($stat1["gid"], $stat2["gid"]) != 0) {

                return static::CMP_MODE;
            }
        }

        return static::CMP_OK;
    }

    public function touch(SyncFileHandler $fileInfo, bool $setSum=false, string $algo=null): bool {
        $stat = $fileInfo->isLink() ? lstat($fileInfo->file) : stat($fileInfo->file);
        $file = $this->file;
        $result = $stat !== false;
        $uid = posix_geteuid();

        if ($this->isLink()) {
            if ($result) {
                lchown($file, $uid == 0 ? $stat["uid"] : $uid);
                lchgrp($file, $stat["gid"]);
            }

        } else if ($result) {
            chmod($file, $stat["mode"]);
            chown($file, $uid == 0 ? $stat["uid"] : $uid);
            chgrp($file, $stat["gid"]);
            touch($file, $stat["mtime"], $stat["atime"]);
        }

        if ($setSum && $this->isFile()) {
            $sum = $fileInfo->sum;
            $algo = $algo ?? $this->algo;

            if ($this->sum !== $sum || !$this->isCompressed()) {
                $newFile = "$this->name#$algo:$sum";

                if (rename($file, $newFile)) {
                    $this->mFile = $newFile;
                    $this->mSum = $sum;

                    if ($sum === null) {
                        $result = false;
                    }

                } else {
                    $result = false;
                }
            }

        } else if ($this->isCompressed()) {
            $newFile = $this->name;

            if (rename($file, $newFile)) {
                $this->mFile = $newFile;
                $this->mSum = null;

            } else {
                $result = false;
            }
        }

        return $result;
    }

    public function remove(): bool {
        if ($this->isDir()) {
            /*
             * Note:
             *      This should never be used, but just in case.
             *      Next sync will try to sort it out, or alert about it.
             */
            if (!@rmdir($this->file)) {
                return rename($this->file, dirname($this->file)."/.".trim(basename($this->file), ".").".d".random_int(0, 1000000));
            }

        } else if ($this->exists()) {
            return unlink($this->file);
        }

        return true;
    }

    public function backup(SyncFileHandler $fileInfo): bool {
        if ($fileInfo->isLink()) {
            if ($this->exists()) {
                if (!$this->remove()) {
                    return false;
                }
            }

            if (symlink($fileInfo->linkTarget, $this->file)) {
                return $this->touch($fileInfo, false);
            }

        } else if ($fileInfo->isDir()) {
            if ($this->isDir()) {
                return $this->touch($fileInfo, false);

            } else if ($this->exists()) {
                if (!$this->remove()) {
                    return false;
                }
            }

            if (mkdir($this->file)) {
                return $this->touch($fileInfo, false);
            }

        } else if ($fileInfo->isFile()) {
            /*
             * The file size must exceed 256bytes in order for the compression
             * to be affective. In many cases you actually encrease the size on files
             * below 256bytes.
             */
            if ($fileInfo->isCompressed() || $fileInfo->size < 256 || COMPR_ALGO == "none") {
                if ($this->exists()) {
                    if (!$this->remove()) {
                        return false;
                    }
                }

                if (copy($fileInfo->file, $this->file)) {
                    return $this->touch($fileInfo, $fileInfo->isCompressed());
                }

            } else {
                $manager = new ComprHandler($this->file, COMPR_ALGO);

                if ($manager->compress($fileInfo->file, $fileInfo->hash)) {
                    return $this->touch($fileInfo, true, COMPR_ALGO);
                }
            }
        }

        return false;
    }

    public function restore(SyncFileHandler $fileInfo): bool {
        /*
         * If it's a folder or a link,
         * then there's no difference between the backup and restore
         */
        if (!$fileInfo->isFile()) {
            return $this->backup($fileInfo);
        }

        if (!$fileInfo->isCompressed()) {
            if ($this->exists()) {
                if (!$this->remove()) {
                    return false;
                }
            }

            if (copy($fileInfo->file, $this->file)) {
                return $this->touch($fileInfo, false);
            }

        } else {
            $manager = new ComprHandler($fileInfo->file, $fileInfo->algo);

            if ($manager->decompress($this->file)) {
                return $this->touch($fileInfo, false);
            }
        }

        return false;
    }
}
